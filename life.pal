/GAME OF LIFE
/KYLE OWEN - 24 MARCH 2019
/UPDATED - 8 APRIL 2019

/NOW WITH 100% MORE VC8E SUPPORT FOR BOTH STORAGE AND NON-STORAGE 'SCOPES

/FOCAL: 11 BY 11
/BASIC: 32 BY 32
/ASSEMBLY: 192 BY 256 (OR BEYOND?)
/THAT WAS THE MAIN REASON FOR WRITING THIS...
/PROBABLY WOULD'VE BEEN EASIER TO WRITE IN FORTRAN, THOUGH.
/I THINK THERE WAS A DECUS VERSION, BUT I CAN'T FIND IT.
/
/DFIELD SELECTS THE FIELD FOR STORING THE BITMAP
/BITMAP IS ORGANIZED AS 192 WIDE BY 256 TALL
/WORD 0 BIT 0 IS TOP LEFT, WORD 7777 BIT 11 IS BOTTOM RIGHT
/INTERNALLY, BIT NUMBER IS STORED AS A NEGATIVE NUMBER, -14 TO -1 (OCTAL!)
/HENCE, BIT IN WORD:
/... -3 -2 -1 | -14 -13 -12 -11 ... -3 -2 -1 | -14 -13 -12 ...
/  WORD - 1   |         CURRENT WORD         |   WORD + 1
/
/AND, LOOKING JUST AT THE WORDS IN THE BITMAP:
/... WORD - WRDCOL - 1 | WORD - WRDCOL | WORD - WRDCOL + 1 ...
/...     WORD - 1      | CURRENT WORD  |      WORD + 1     ...
/... WORD + WRDCOL - 1 | WORD + WRDCOL | WORD + WRDCOL + 1 ...

/IN THIS WORLD, THE SCREEN WRAPS FROM LEFT TO RIGHT, TOP TO BOTTOM
/IT WOULDN'T BE HARD TO TERMINATE LIFE AT SCREEN BOUNDARIES, THOUGH
/
/A LITTLE SUMMARY OF OPERATION:
/FIRST, BITMAP IS CLEARED, THEN INITIAL CONDITIONS ARE LOADED.
/THEN, THREE ROWS ARE COPIED INTO THREE CACHE ROWS.
/FOR EACH ROW COPIED, A BIT IN LIFDET IS SET OR CLEARED TO INDICATE WHETHER
/OR NOT THE CACHE ACTUALLY HAS ANY LIFE. IF THERE'S NO LIFE, WE CAN TAKE A
/SHORTCUT.
/SINCE WE START WITH PIXEL (0,0), AKA THE LEFT PIXEL OF THE FIRST ROW,
/THE THREE ROWS TO CACHE ARE THE ROW ABOVE US, OUR CURRENT ROW, AND THE
/ROW BELOW US. THE ROW ABOVE US IS ACTUALLY THE LAST ROW IN THE BITMAP
/BECAUSE OF WRAPPING.
/
/NOW, ASSUMING WE HAVE LIFE IN THE CACHE...
/
/IF YOU ARE INSIDE A WORD SUCH THAT YOU WON'T WRAP TO SURROUNDING WORDS AND THE WORD IS ZERO,
/YOU CAN SKIP RIGHT ON TO THE END OF THAT WORD...JUST ANOTHER OPTIMIZATION FOR SPEED.
/
/OTHERWISE, WE ITERATE THROUGH THE CACHE ROWS, COUNTING EVERY NEIGHBORHOOD OF 9 PIXELS.
/WHEN WE ARE AT THE EDGE OF A WORD, EITHER BIT 0 (-14) OR BIT 11 (-1), WE NEED
/TO COUNT PIXELS IN THE ADJACENT WORDS. OTHERWISE, WE ONLY CONSIDER OUR CURRENT WORD,
/PLUS THE WORD ABOVE US AND THE WORD BELOW US, OF COURSE.
/
/ONCE WE HAVE COUNTED THE NEIGHBORHOOD, WE COMPARE THE TOTAL LIVE CELLS TO 3 AND 4. IF
/THE NUMBER OF LIVE CELLS IS 3, THE MIDDLE CELL WILL BE ALIVE. IF THE NUMBER IS 4, THE
/MIDDLE CELL WILL REMAIN UNCHANGED. EVERY OTHER SUM RESULTS IN...DEATH!
/
/ONCE WE ARE TO THE END OF THE CURRENT ROW, THE CACHE MUST BE UPDATED. FORTUNATELY, THIS IS
/PRETTY EASY. THE CURRENT (MIDDLE) CACHE ROW BECOMES THE TOP ROW, THE BOTTOM ROW BECOMES THE 
/CURRENT ROW, AND THE TOP ROW BECOMES THE BOTTOM ROW. THE BOTTOM ROW OF THE CACHE (FORMERLY
/THE TOP ROW OF THE CACHE) IS COPIED OVER WITH THE ROW BELOW THE CURRENT ROW OF THE BITMAP.
/INSTEAD OF DOING A BUNCH OF COPYING, WE JUST CHANGE THE POINTERS TO THE CACHE ROWS, AND ONLY
/COPY THE ONE NEW ROW. NOT TOO BAD, RIGHT? OH, BE SURE TO UPDATE LIFDET TO GIVE US A POSSIBLE
/SHORTCUT IF THERE'S NO MORE LIFE IN THE CACHE FOR NEXT TIME.
/
/IF THERE'S NO LIFE IN THE CACHE, UPDATE THE CACHE AND TRY AGAIN.
/
/THE PROGRAM USES WORDS 0 TO 7 AS A BIT COUNT LOOKUP TABLE FOR EXTRA SPEED. MAYBE 
/THERE'S A FASTER WAY TO COUNT BITS? IF SO, PLEASE FORWARD THIS ON TO ME!
/
/THE PROGRAM ALSO USES WORDS 7764 TO 7777 (-14 TO -1, RIGHT?) FOR THE BITMASK. 
/
/THERE'S ALSO A ROTATE SUBROUTINE WHICH TRIES TO GO FOR SPEED. MAYBE IT CAN BE OPTIMIZED
/AS WELL?
/
/PARTING THOUGHTS: YOU COULD CRAM THIS INTO ONE FIELD IF YOU WANTED TO REDUCE THE BITMAP SIZE
/BY A BIT (HEH); WRAPPING VERTICALLY IS NO LONGER QUITE AS TRIVIAL, THOUGH...FOR AN 8K MACHINE
/WITH AN OS, I BELIEVE REDUCING THE BITMAP SIZE WILL BE REQUIRED.
/
/IT TURNS OUT THAT PRINTING TO THE TERMINAL TAKES A...SURPRISINGLY LARGE AMOUNT OF TIME.
/
/WRDCOL, AKA THE NUMBER OF WORD COLUMNS (AKA THE NUMBER OF WORDS IN A ROW) SHOULD DEFINITELY BE
/A POWER OF TWO, AS THE PROGRAM ASSUMES IT WILL BE. 
/SMALLER WOULD PROBABLY BE FINE, BUT WILL INCREASE THE NUMBER OF ROWS.
/BIGGER WOULD BE FINE TOO, GIVEN PAGE ZERO IS DECLUTTERED.
/
/ANOTHER BIG IMPROVEMENT WOULD BE THE ABILITY TO STORE INITIAL CONDITIONS IN AN EASY TO USE
/FILE FORMAT, PERHAPS LOADING FROM OS/8 (OR P?S/8). RIGHT NOW, THERE'S NO SUPPORT FOR AN OS.
/
/ADDING THE ABILITY TO NOT PRINT (OR DRAW) TO INCREASE SPEED MAY BE A GOOD ADDITION.
/
/STATISTICS WOULD BE NICE. A RUNNING COUNT OF LIVE CELLS PLUS THE GENERATION, PERHAPS?
/
/THE CURLY BRACES IN THE SOURCE COMMENTS ARE SOLELY FOR BRACKET MATCHING, SINCE GT AND LT SIGNS
/ARE NOT USED AS MODERN BRACKETS. HELPFUL IF YOU'RE USING VIM OR EMACS. NOT HELPFUL IF YOU'RE
/USING EDIT, EDLIN, ETC.

/BASIC CONFIGURATION
VC8E=1		/IF ZERO, ASSUMES A (VERY LARGE!) TERMINAL; IF ONE, USE A VC8E
STORE=0		/IF ZERO, ASSUMES A NON-STORAGE OSCILLOSCOPE; IF ONE, A STORAGE 'SCOPE
VT100=1		/IF ZERO, DOESN'T ASSUME A VERY SMART TERMINAL; IF ONE, A VT100-LIKE TERMINAL
PRTDOT=0	/IF ZERO, PRINTS SPACES FOR DEATH; IF ONE, DOTS
WRDCOL=20	/16 WORDS TIMES 12 BITS IS 192 ACROSS; CHANGE AT YOUR OWN RISK!
DFIELD=10	/BITMAP FIELD. 10 FOR FIELD 1, 20 FOR FIELD 2. FIELD 0 IS NOT RECOMMENDED.
NOPRT=0		/NO PRINT FOR DEBUGGING
RSTRSC=0	/RASTER SHORTCUT FOR DEBUGGING

/FUN INITIAL CONDITIONS; USE COMBINATIONS AS YOU LIKE
/DEFINITIONS ARE AT THE END OF THE FILE
GLDERS=0
GOSPER=0
RPENTO=0
MWSS=0
HWSS=0
DIEHARD=0
ACORN=0
BREED=0
FILLER=1
MAXFIL=0

IFNZRO NOPRT < /{
TSF=SKP
TLS=NOP
> /}

/FOR DUMB TERMINALS, OR IF WE PRINT DOTS, DEATH IS SLOW
SLODTH=0
IFZERO VC8E < /{
IFZERO VT100 < /{
SLODTH=1
> /}
IFNZRO PRTDOT < /{
SLODTH=1
> /}
> /}

/VC8E DEFINITIONS
IFNZRO VC8E< /{
DISD=	6052
DILX=	6053
DILY=	6054
DIXY=	6055 
DILE=	6056
> /}

/BIT COUNT TABLE
	*0
	0
	1
	1
	2
	1
	2
	2
	3

	*10
PRIDX,	0
CPTR1,	0
CPTR2,	0
RLEPTR,	0

	*20
/CURRENT WORD IN BITMAP
ADDR,	0

/CURRENT BIT IN WORD
CURBIT,	0

/NEIGHBORHOOD TOTAL
TOTAL,	0

/LIFE DETECTED IN CACHE
LIFDET,	0

/CACHE POINTERS
TOPPTR,	0
MIDPTR,	0
BOTPTR,	0

/MISC STUFF
CNT,	0
TEMP,	0
TMPPTR,	0

/STUFF FOR VC8E
IFNZRO VC8E < /{
STARTX,	-600
STARTY,	1000
X,	0
Y,	0
> /}

/CACHE
	*40
CACHE1,	ZBLOCK WRDCOL
CACHE2,	ZBLOCK WRDCOL
CACHE3,	ZBLOCK WRDCOL

/ROTATE AC RIGHT BY (2 - BIT) TIMES, WHERE BIT IS -2 TO -11 DECIMAL
/THE SUBROUTINE DOES NOT LIKE WHEN YOU CALL IT WITH -1 OR -12, THOUGH...
/THEN, AND RESULT WITH 7 AND RETURN
DOROT,	0
	DCA ROT
	TAD (ROTTBL+1
	TAD CURBIT
	DCA JMPLOC
	TAD ROT
	JMP I JMPLOC
/ROTATE TABLE
	JMP ERR
	JMP FOURL
	JMP FIVEL
	JMP SIXL
	JMP SIXR
	JMP FIVER
	JMP FOURR
	JMP THREER
	JMP TWOR
	JMP ONER
	JMP DOAND
ROTTBL,	JMP ERR

ERR,	HLT
	JMP I DOROT

SIXL,	RTL
FOURL,	RTL
TWOL,	RTL
	AND (7
	JMP I DOROT

FIVEL,	RTL
THREEL,	RTL
ONEL,	RAL
	AND (7
	JMP I DOROT

SIXR,	RTR
FOURR,	RTR
TWOR,	RTR
	AND (7
	JMP I DOROT

FIVER,	RTR
THREER,	RTR
ONER,	RAR
DOAND,	AND (7
	JMP I DOROT

ROT,	0
JMPLOC,	0

/BIT MASK TABLE
	*7764	
	4000
	2000
	1000
	400
	200
	100
	40
	20
	10
	4
	2
	1

	*200
START,	JMS INIT	/INITIALIZE THE BITMAP
	6040		/CLEAR TTY FLAG
IFNZRO VC8E^STORE < /{
	CLA		/SET VC8E FOR STORAGE MODE
	TAD (20
	DILE
> /}

	CLA		/INITIALIZE CURRENT BIT AND ADDRESS
	TAD (-14
	DCA CURBIT	/CURBIT = -14 (AKA BIT 0)
	DCA ADDR	/ADDR = 0
	DCA LIFDET
	DCA TEMP
	TAD (CACHE1	/SET UP THE CACHE
	DCA TOPPTR
	TAD (CACHE2
	DCA MIDPTR
	TAD (CACHE3
	DCA BOTPTR

	TAD (-WRDCOL-1	/COPY INITIAL CACHE
	DCA CPTR1
	TAD (CACHE1-1
	DCA CPTR2
	TAD (-WRDCOL	/COPYING ONE ROW
	DCA CNT
	CDF DFIELD
	TAD I CPTR1
	SZA
	ISZ TEMP	/INCREMENT IF LIFE DETECTED
	CDF 0
	DCA I CPTR2
	ISZ CNT
	JMP .-7

	TAD TEMP	/ANY LIFE?
	SZA CLA
	IAC		/YES
	TAD LIFDET
	CLL RAL
	DCA LIFDET
	DCA TEMP

	TAD (-WRDCOL	/COPYING ONE ROW TO WHERE WE LEFT OFF
	DCA CNT
	CDF DFIELD
	TAD I CPTR1
	SZA
	ISZ TEMP	/INCREMENT IF LIFE DETECTED
	CDF 0
	DCA I CPTR2
	ISZ CNT
	JMP .-7

	TAD TEMP	/ANY LIFE?
	SZA CLA
	IAC		/YES
	TAD LIFDET
	CLL RAL
	DCA LIFDET
	DCA TEMP

	TAD (-WRDCOL	/COPYING ONE ROW TO WHERE WE LEFT OFF
	DCA CNT
	CDF DFIELD
	TAD I CPTR1
	SZA
	ISZ TEMP	/INCREMENT IF LIFE DETECTED
	CDF 0
	DCA I CPTR2
	ISZ CNT
	JMP .-7

	TAD TEMP	/ANY LIFE?
	SZA CLA
	ISZ LIFDET	/YES
	JMP CHKLIF	/JUMP TO THE MAIN LOOP

	PAGE

CHKLIF,	TAD LIFDET	/ANY LIFE IN THE CACHE?
	SNA CLA
	JMP NOLIFE	/NOPE, SHORTCUT!
DOLIFE,	TAD CURBIT	/ARE WE AT A WORD EDGE?
	TAD (14		/CHECK LEFT WORD EDGE
	SZA
	JMP NLBIT	/NO, NOT THE LEFT WORD EDGE
	TAD I TOPPTR	/YES, GET TOP WORD
	SNA
	JMP .+6		/NOTHING TO DO IF WORD IS ZERO
	RTL		/GET TOP TWO BITS DOWN LOW
	RAL
	AND (3		/JUST KEEP THE TWO
	DCA TEMP
	TAD I TEMP	/AND COUNT THEM
	DCA TOTAL
	TAD I MIDPTR	/DO THE SAME FOR MIDDLE
	SNA
	JMP .+10	/NOTHING TO DO IF WORD IS ZERO
	RTL
	RAL
	AND (3
	DCA TEMP
	TAD I TEMP
	TAD TOTAL
	DCA TOTAL
	TAD I BOTPTR	/DO THE SAME FOR BOTTOM
	SNA
	JMP .+10	/NOTHING TO DO IF WORD IS ZERO
	RTL
	RAL
	AND (3
	DCA TEMP
	TAD I TEMP
	TAD TOTAL
	DCA TOTAL
	CMA		/STILL MISSING THE LEFT COLUMN
	TAD ADDR	/GET WORD TO OUR LEFT, WRAP AS NECESSARY
	AND (WRDCOL-1
	TAD (CACHE1	/DON'T CARE ABOUT ORDER OF BITS ANYWAYS!
	DCA TMPPTR
	IAC
	AND I TMPPTR	
	SZA CLA
	ISZ TOTAL
	TAD (WRDCOL	/DO NEXT CACHED ROW
	TAD TMPPTR
	DCA TMPPTR
	IAC
	AND I TMPPTR	
	SZA CLA
	ISZ TOTAL
	TAD (WRDCOL	/AND THE LAST CACHED ROW
	TAD TMPPTR
	DCA TMPPTR
	IAC
	AND I TMPPTR	
	SZA CLA
	ISZ TOTAL
	JMP DOCALC	/ALL DONE FOR NOW

NLBIT,	TAD (-13	/HOW ABOUT RIGHT WORD EDGE?
	SZA CLA
	JMP NOTEDG	/NO, NOT AT EITHER WORD EDGE
	TAD I TOPPTR	/YES, GET TOP WORD
	SNA
	JMP .+4		/NOTHING TO DO IF WORD IS ZERO
	AND (3		/JUST KEEP THE TWO BOTTOM BITS
	DCA TEMP
	TAD I TEMP	/AND COUNT THEM
	DCA TOTAL
	TAD I MIDPTR	/DO THE SAME FOR MIDDLE
	SNA
	JMP .+6		/NOTHING TO DO IF WORD IS ZERO
	AND (3
	DCA TEMP
	TAD I TEMP
	TAD TOTAL
	DCA TOTAL
	TAD I BOTPTR	/DO THE SAME FOR BOTTOM
	SNA
	JMP .+6		/NOTHING TO DO IF WORD IS ZERO
	AND (3
	DCA TEMP
	TAD I TEMP
	TAD TOTAL
	DCA TOTAL
	IAC		/STILL MISSING THE RIGHT COLUMN
	TAD ADDR	/GET WORD TO OUR RIGHT, WRAP AS NECESSARY
	AND (WRDCOL-1
	TAD (CACHE1	/DON'T CARE ABOUT ORDER OF BITS ANYWAYS!
	DCA TMPPTR
	TAD I TMPPTR	
	SPA CLA
	ISZ TOTAL
	TAD (WRDCOL	/DO NEXT CACHED ROW
	TAD TMPPTR
	DCA TMPPTR
	TAD I TMPPTR	
	SPA CLA
	ISZ TOTAL
	TAD (WRDCOL	/AND THE LAST CACHED ROW
	TAD TMPPTR
	DCA TMPPTR
	TAD I TMPPTR	
	SPA CLA
	ISZ TOTAL
	JMP DOCALC	/ALL DONE FOR NOW

	PAGE

NOTEDG,	TAD I TOPPTR	/GET TOP WORD
	SNA
	TAD I MIDPTR	/GET MIDDLE WORD
	SNA
	TAD I BOTPTR	/GET BOTTOM WORD
	SNA CLA		/ANY LIFE?
	JMP NWRDLF	/NO, NO LIFE IN CURRENT WORD AREA
	TAD I TOPPTR	/GET TOP WORD
	JMS DOROT	/ROTATE AS NECESSARY
	DCA TEMP	/SAVE IT
	TAD I TEMP	/AND COUNT THE BITS
	DCA TOTAL	/SAVE THAT AS TOTAL SO FAR
	TAD I MIDPTR	/GET MIDDLE WORD
	JMS DOROT
	DCA TEMP
	TAD I TEMP
	TAD TOTAL	/ADD TO TOTAL
	DCA TOTAL
	TAD I BOTPTR	/GET BOTTOM WORD
	JMS DOROT
	DCA TEMP
	TAD I TEMP
	TAD TOTAL	/ADD TO TOTAL
	DCA TOTAL
	JMP DOCALC

NWRDLF,	CMA		/SKIP TO LAST BIT OF WORD
	DCA CURBIT
IFZERO VC8E < /{
	TAD (-12	/SKIPPING 10 DEAD PIXELS
	DCA CNT
IFNZRO PRTDOT < /{
	TAD (56
> /}
IFZERO PRTDOT < /{
	TAD (40
> /}
	TSF
	JMP .-1
	TLS
	ISZ CNT
	JMP .-4
	CLA
> /}
	JMP DOLIFE

DOCALC,	TAD TOTAL
	TAD (-3
	SNA
	JMP BIRTH	/EXACTLY 3
	TAD (-1
	SNA CLA
	JMP SAME	/EXACTLY 4
	JMP DEATH	/OTHERWISE... :(

SAME,	TAD I CURBIT	/GET MASK
	AND I MIDPTR	/AND WITH CURRENT WORD
	SZA CLA		/IS IT ALIVE OR DEAD?
	JMP BIRTH

DEATH,	
IFZERO VC8E < /{
	JMS PRTDTH	/PRINT DEATH (AWW...)
> /}
	TAD I CURBIT	/CLEAR THE BIT IN THE BITMAP
	CMA
	CDF DFIELD
	AND I ADDR
	DCA I ADDR
	CDF 0
	JMP BITLP

BIRTH,	
IFNZRO VC8E^STORE < /{
	JMS DISPT	/VC8E STORAGE, DISPLAY A POINT
> /}
IFZERO VC8E < /{
	JMS PRTLIF	/PRINT LIFE (YAY)
> /}
	TAD I CURBIT	/GET MASK
	CMA
	CDF DFIELD
	AND I ADDR	/COMPLEMENT MASK AND 'AND' IT WITH CURRENT WORD
	CDF 0
	TAD I CURBIT	/ADD IN LIVE CELL
	CDF DFIELD
	DCA I ADDR	/SAVE IT
	CDF 0

BITLP,	ISZ CURBIT	/NEXT BIT
	JMP DOLIFE	/NOTHING ELSE TO DO HERE!
	CLA		/NEED TO GO TO NEXT WORD AND RESET CURRENT BIT TO -14
	TAD (-14
	DCA CURBIT
	ISZ ADDR	/FINAL BITMAP ADDRESS?
	JMP CHKROW	/NO
	JMP FINAL	/YES

CHKROW,	TAD ADDR	/END OF ROW?
	AND (WRDCOL-1
	SZA CLA
	JMP NOTDUN	/NO
IFZERO VC8E < /{
	JMS DOCRLF	/YES
> /}
	JMS UCACHE	/UPDATE CACHE
	JMP CHKLIF

NOTDUN,	ISZ TOPPTR	/NEXT WORDS
	ISZ MIDPTR
	ISZ BOTPTR
	JMP DOLIFE

NOLIFE,	
IFZERO VC8E < /{
	JMS DTHROW	/PRINT A ROW OF DEATH...
> /}
	TAD ADDR	/END OF BITMAP?
	TAD (WRDCOL
	SZA
	JMP NOTFIN	/NO
FINAL,			/YES
IFZERO VC8E < /{
	JMS PRTHOM	/GO BACK HOME
> /}
IFNZRO VC8E < /{
	JMS RASERA	/EITHER DISPLAY A RASTER OR ERASE THE SCREEN
> /}
NOTFIN,	DCA ADDR
	JMS UCACHE	/UPDATE CACHE
	JMP CHKLIF	/AND TRY AGAIN

	PAGE

/UPDATE CACHE
UCACHE,	0
	CLA		/MIDPTR TO TOPPTR, BOTPTR TO MIDPTR, AND TOPPTR TO BOTPTR
	TAD TOPPTR
	AND (-WRDCOL
	DCA TEMP
	TAD MIDPTR
	AND (-WRDCOL
	DCA TOPPTR
	TAD BOTPTR
	AND (-WRDCOL
	DCA MIDPTR
	TAD TEMP
	DCA BOTPTR
	DCA TEMP
	TAD LIFDET	/UPDATE THE LIFE DETECTION
	CLL RAL
	AND (6
	DCA LIFDET

	/NOW, ONLY REFRESH BOTTOM CACHED ROW
	CMA
	TAD ADDR	/ADDR IS POINTING TO THE NEXT ROW IN THE BITMAP
	TAD (WRDCOL	/WE NEED THE NEXT ROW DOWN
	DCA CPTR1
	CMA
	TAD BOTPTR
	DCA CPTR2
	TAD (-WRDCOL	/COPYING ONE ROW
	DCA CNT
	CDF DFIELD
	TAD I CPTR1
	SZA		/ANY LIFE DETECTED?
	ISZ TEMP	/YES
	CDF 0
	DCA I CPTR2
	ISZ CNT
	JMP .-7

	TAD TEMP	/ANY LIFE?
	SZA CLA
	ISZ LIFDET	/YES

	JMP I UCACHE

IFZERO VC8E < /{
/VT100 HOME SEQUENCE, ESC[H
PRTHOM,	0
	CLA
	TAD (HOMSEQ-1
	JMS PUTS
	JMP I PRTHOM
IFNZRO VT100 < /{
HOMSEQ,	33
	133
	110
> /}
IFZERO VT100 < /{
HOMSEQ,	14
> /}
	0

IFNZRO VT100 < /{
/VT100 ERASE LINE, ESC[2K, PLUS CRLF
ERALIN,	0
	CLA
	TAD (ERASEQ-1
	JMS PUTS
	JMP I ERALIN
ERASEQ,	33
	133
	62
	113
	15
	12
	0
> /}

/PRINT NULL-TERMINATED STRING
PUTS,	0
	DCA PRIDX
	TAD I PRIDX
	SNA
	JMP I PUTS
	TSF
	JMP .-1
	TLS
	CLA
	JMP .-7

/PRINT DEATH
PRTDTH,	0
	CLA
IFNZRO PRTDOT < /{
	TAD (56
> /}
IFZERO PRTDOT < /{
	TAD (40
> /}
	TSF
	JMP .-1
	TLS
	CLA
	JMP I PRTDTH

/PRINT A ROW OF DEATH
DTHROW,	0
IFZERO SLODTH < /{
	JMS ERALIN
> /}
/PRTDOT=1 OR VT100=0
IFNZRO SLODTH < /{
	CLA
	TAD (-WRDCOL^14	/12 PIXELS PER WORD
	DCA CNT
IFNZRO PRTDOT < /{
	TAD (56
> /}
IFZERO PRTDOT < /{
	TAD (40
> /}
	TSF
	JMP .-1
	TLS
	ISZ CNT
	JMP .-4
	JMS DOCRLF
> /}
	JMP I DTHROW

/PRINT A # FOR LIFE
PRTLIF,	0
	CLA
	TAD (43
	TSF
	JMP .-1
	TLS
	CLA
	JMP I PRTLIF

DOCRLF,	0
	CLA
	TAD (CRLF-1
	DCA PRIDX
	TAD I PRIDX
	SNA
	JMP I DOCRLF
	TSF
	JMP .-1
	TLS
	CLA
	JMP .-7
CRLF,	15
	12
	0
> /}

IFNZRO VC8E < /{
IFNZRO STORE < /{
DISPT,	0
	CLA CLL
	TAD ADDR	/X = (12 * (ADDR & (WRDCOL-1))) + CURBIT + 12 + STARTX
	AND (WRDCOL-1
	DCA X
	TAD X
	TAD X
	TAD X
	RTL
	TAD CURBIT
	TAD (12
	CLL RTL
	TAD STARTX
	DILX
	DCA X

	TAD ADDR	/Y = (((ADDR SHR 4) & 0377) + STARTY)
	RTR
	RTR
	AND (377
	CLL RTL
	CMA IAC
	TAD STARTY
	DILY
	DCA Y

	DISD
	JMP .-1
	DIXY		/X,Y
	JMP I DISPT
> /}

IFZERO STORE < /{
/DO A RASTER SCAN OF THE BITMAP AND DISPLAY IT
/IF THE PREVIOUS WORD HAD ACTIVITY AND WE HAVE NOT YET FINISHED A LINE, THE 
/Y DAC IS ALREADY SET UP FOR US. NO NEED TO RECALCULATE IT. THE X DAC IS
/ACTUALLY SET UP AS WELL, SO THAT'S HANDY.
RASTER,	0
	CLA
	DCA ADDR
	TAD (-14
	DCA CURBIT
IFNZRO RSTRSC < /{
	TAD STARTX
	DILX
	CLA
	TAD STARTY
	DILY
	CLA CMA
	DCA SHRTCT	/SET UP FOR TAKING SHORTCUT
> /}

RASLP,	CDF DFIELD
	TAD I ADDR
	CDF 0
	SZA
	JMP DODRAW
IFNZRO RSTRSC < /{
	DCA SHRTCT	/CAN'T DO SHORTCUT
> /}
RSCONT,	ISZ ADDR
	JMP RASLP
	JMP I RASTER	/YES, ALL DONE

DODRAW,	DCA DRWWRD	/STORE WORD TO PLOT
IFNZRO RSTRSC < /{
	ISZ SHRTCT	/CAN WE DO THE SHORTCUT?
	JMP CALCXY	/NO, WE CAN'T
SKPCAL,	TAD ADDR	/MAYBE...ARE WE AT A NEW LINE?
	AND (WRDCOL-1
	SZA CLA
	JMP SCTCON	/NO, DON'T CALCULATE Y IF WE DON'T HAVE TO
	TAD STARTX	/YES, BEGINNING OF LINE
	DILX		/RESET X
	DCA X
	JMP CALCY	/AND JUST CALCULATE Y
> /}

CALCXY,	TAD ADDR	/X = (4 * 12 * (ADDR & (WRDCOL-1))) + STARTX
	AND (WRDCOL-1
	DCA X
	TAD X
	TAD X
	TAD X
	CLL RTL
	CLL RTL
	TAD STARTX
	DILX
	DCA X

CALCY,	TAD ADDR	/Y = STARTY - (4 * ((ADDR SHR 4) & 0377))
	RTR
	AND (1774
	CMA IAC
	TAD STARTY
	DILY
	DCA Y

IFNZRO RSTRSC < /{
SCTCON,	CMA		/WE CAN TAKE A SHORTCUT NEXT TIME, MAYBE...
	DCA SHRTCT
> /}

IFNZRO RSTRSC < /{
WRDLP,	TAD DRWWRD
	AND I CURBIT
	SNA CLA		/ARE WE PLOTTING A BIT OR NOT?
	JMP NEXTX	/NOPE, SKIP AHEAD
	DISD		/YES, WAIT FOR DACS TO SETTLE
	JMP .-1
	DIXY

NEXTX,	TAD X		/INCREMENT X BY 4 BECAUSE OF OUR SCALE
	TAD (4
	DILX
	DCA X
	ISZ CURBIT
	JMP WRDLP
	TAD (-14
	DCA CURBIT
	JMP RSCONT

SHRTCT,	0
> /}

IFZERO RSTRSC < /{
WRDLP,	TAD DRWWRD
	AND I CURBIT
	SNA CLA		/ARE WE PLOTTING A BIT OR NOT?
	JMP NXTBIT	/NOPE, SKIP AHEAD
	DISD		/YES, WAIT FOR DACS TO SETTLE
	JMP .-1
	DIXY

NXTBIT,	ISZ CURBIT
	JMP NEXTX
	TAD (-14
	DCA CURBIT
	JMP RSCONT

NEXTX,	TAD X		/INCREMENT X BY 4 BECAUSE OF OUR SCALE
	TAD (4
	DILX
	DCA X
	JMP WRDLP

SHRTCT,	0
> /}

DRWWRD,	0
> /}

/DEPENDING ON IF WE HAVE A STORAGE 'SCOPE OR NOT, EITHER
/RASTER THE BITMAP HERE FOR SEVERAL LOOPS, OR ERASE THE
/SCREEN. YOU COULD ADD A DELAY BEFORE THE ERASE TO ADMIRE
/THE COMPLETED CYCLE LONGER.
RASERA,	0
IFNZRO STORE < /{
	CLA
	TAD (10		/ERASE VC8E
	DILE
	DISD		/WAIT FOR ERASE TO COMPLETE
	JMP .-1
	CLA
> /}
IFZERO STORE < /{
	CLA
	TAD (-20	/16 LOOPS
	DCA CNT
	JMS RASTER	/DO THE RASTER
	ISZ CNT
	JMP .-2
> /}
	JMP I RASERA
> /}

	PAGE

/RUN-LENGTH ENCODING INITIALIZER
/
/TAKES MULTIPLES OF THREE ARGUMENTS
/1. POINTER TO RLE DATA
/2. X ADDRESS IN BITMAP, 0 TO 191 DECIMAL
/3. Y ADDRESS IN BITMAP, 0 TO 255 DECIMAL
/AND REPEAT
/
/RLE IS SUPPLIED AS:
/TAG!COUNT; TAG!COUNT; TAG!COUNT; ...ETC.
/
/WHERE COUNT IS 1 TO 192, AND TAG IS:
/6000 OCTAL - DEAD
/4000 OCTAL - ALIVE
/1000 OCTAL - END OF LINE
/0 TERMINATES THE SEQUENCE
/IF COUNT IS ZERO, IT IS ASSUMED TO BE 1
/
/KEEPS GOING UNTIL THE POINTER TO RLE DATA IS ZERO
RLE,	0
NXTRLE,	CLA CMA
	TAD I RLE	/GET POINTER TO RLE
	DCA RLEPTR
	TAD RLEPTR	/WAS IT ZERO?
	CMA
	SNA CLA
	JMP RLEDUN
	ISZ RLE
	TAD I RLE	/GET X VALUE
	DCA SBIT
	DCA SADDR
	TAD SBIT
	TAD (-14	/DIVIDE BY 12
	SPA
	JMP DIVDUN	/NO MORE TO DIVIDE
	ISZ SADDR
	JMP .-4
DIVDUN,	DCA SBIT
	TAD SBIT
	DCA CURBIT
	ISZ RLE
	TAD I RLE	/GET Y VALUE
	CLL RTL		/MULTIPLY BY 16
	RTL
	TAD SADDR	/ADD TO X OFFSET
	DCA SADDR
	TAD SADDR
	DCA ADDR
	ISZ RLE		/POINT TO RETURN

RMAIN,	DCA CURSTA	/RESET CURRENT STATE
	TAD I RLEPTR	/GET DATA
	SNA		/END OF SEQUENCE?
	JMP NXTRLE	/GET NEXT RLE
	CLL RAL
	SNL		/NOPE, WHAT WAS IT?
	ISZ CURSTA
	SMA
	ISZ CURSTA	/CURSTA = 0 FOR DEAD, 1 FOR LIFE, 2 FOR EOL
	RAR		/GO BACK THE OTHER WAY
	AND (377	/KEEP JUST THE COUNT
	CMA IAC		/NEGATE IT
	SNA		/IF IT IS ZERO
	CMA		/MAKE IT ONE
	DCA RLECNT	/STORE IT

RLOOP,	TAD CURSTA	/LIFE OR DEATH OR EOL?
	SNA
	JMP RCONT	/0 FOR DEATH
	RAR
	SZL CLA
	JMP RLIVE	/1 FOR LIFE
	JMP NEXTLN	/2 FOR NEXT LINE

RLIVE,	TAD I CURBIT	/GET MASK
	CMA
	CDF DFIELD
	AND I ADDR	/COMPLEMENT MASK AND 'AND' IT WITH CURRENT WORD
	CDF 0
	TAD I CURBIT	/ADD IN LIVE CELL
	CDF DFIELD
	DCA I ADDR	/SAVE IT
	CDF 0

RCONT,	ISZ CURBIT	/NEXT BIT
	JMP RCHECK
	CLA		/NEED TO GO TO NEXT WORD AND RESET CURRENT BIT TO -14
	TAD (-14
	DCA CURBIT
	TAD ADDR
	IAC
	AND (WRDCOL-1
	DCA TEMP
	TAD ADDR
	AND (-WRDCOL
	TAD TEMP
	DCA ADDR
RCHECK,	ISZ RLECNT	/ANY MORE TO DO?
	JMP RLOOP	/YES
	JMP RMAIN	/NOPE, GET MORE DATA

NEXTLN,	TAD SBIT
	DCA CURBIT
	TAD SADDR
	TAD (WRDCOL
	DCA SADDR
	TAD SADDR
	DCA ADDR
	JMP RCHECK

RLEDUN,	ISZ RLE
	JMP I RLE

CURSTA,	0
CURDAT,	0
SADDR,	0
SBIT,	0
RLECNT,	0

	PAGE

INIT,	0
	CLA		/ZERO PLAYING FIELD
	DCA ADDR
	CDF DFIELD
	DCA I ADDR
	ISZ ADDR
	JMP .-2
	CDF 0
	JMS RLE
IFNZRO GLDERS < /{
	RGLIDR; 0; 0
	/RGLIDR; 0; 7
> /}
IFNZRO GOSPER < /{
	RGSPER; 10; 10
	/RGSPER; 40; 0
	/RGSPER; 100; 0
> /}
IFNZRO RPENTO < /{
	RRPENT; 137; 176
> /}
IFNZRO MWSS < /{
	RMWSS; 200; 200
> /}
IFNZRO HWSS < /{
	RHWSS; 200; 220
> /}
IFNZRO DIEHARD < /{
	RDIHRD; 137; 176
> /}
IFNZRO ACORN < /{
	RACORN; 137; 176
> /}
IFNZRO BREED < /{
	RBREED; 0; 0
> /}
IFNZRO FILLER < /{
	RFILL; 110; 163
> /}
IFNZRO MAXFIL < /{
	RMAX; 110; 163
> /}
	0		/END OF INITIALIZATION
	JMP I INIT

/RLE INFORMATION

B=6000	/DEAD
O=4000	/ALIVE
L=1000	/END OF LINE
E=0	/END OF RLE

RGLIDR,	DECIMAL
	1!B;1!O;L
	2!B;1!O;L
	3!O;E
	OCTAL

RGSPER, DECIMAL
	24!B;O;L
	22!B;O;B;O;L
	12!B;2!O;6!B;2!O;12!B;2!O;L
	11!B;O;3!B;O;4!B;2!O;12!B;2!O;L
	2!O;8!B;O;5!B;O;3!B;2!O;L
	2!O;8!B;O;3!B;O;B;2!O;4!B;O;B;O;L
	10!B;O;5!B;O;7!B;O;L
	11!B;O;3!B;O;L
	12!B;2!O;E
	OCTAL

RRPENT,	DECIMAL
	B;2!O;L;2!O;B;L;B;O;E
	OCTAL

RMWSS,	DECIMAL
	3!B;O;2!B;L;B;O;3!B;O;L;O;5!B;L;O;4!B;O;L;5!O;E
	OCTAL
	
	PAGE

RHWSS,	DECIMAL
	3!B;2!O;2!B;L;B;O;4!B;O;L;O;6!B;L;O;5!B;O;L;6!O;E
	OCTAL

RDIHRD,	DECIMAL
	6!B;O;B;L;2!O;6!B;L;B;O;3!B;3!O;E
	OCTAL

RACORN,	DECIMAL
	B;O;5!B;L;3!B;O;3!B;L;2!O;2!B;3!O;E
	OCTAL

RBREED,	DECIMAL
	133!B;O;L;134!B;O;L;130!B;O;3!B;O;L;131!B;4!O;3!L;130!B;O;L;131!B;O;L;132!B;O;L
	132!B;O;L;131!B;2!O;4!L;133!B;O;L;134!B;O;L;130!B;O;3!B;O;L;131!B;4!O;9!L;96!B;O;L
	97!B;O;L;93!B;O;3!B;O;L;94!B;4!O;8!L;3!B;O;L;4!B;O;L;O;3!B;O;L;B;4!O;E
	OCTAL

RFILL,	DECIMAL
	20!B;3!O;3!B;3!O;L;19!B;O;B;B;O;3!B;O;B;B;O;L;4!O;18!B;O;3!B;O;18!B;4!O;L
	O;3!B;O;17!B;O;3!B;O;17!B;O;3!B;O;L;O;8!B;O;12!B;O;3!B;O;12!B;O;8!B;O;L
	B;O;B;B;O;B;B;O;O;B;B;O;25!B;O;B;B;O;O;B;B;O;B;B;O;L
	6!B;O;5!B;O;7!B;3!O;3!B;3!O;7!B;O;5!B;O;L;6!B;O;5!B;O;8!B;O;5!B;O;8!B;O;5!B;O;L
	6!B;O;5!B;O;8!B;7!O;8!B;O;5!B;O;L
	B;O;B;B;O;B;B;O;O;B;B;O;B;B;O;O;4!B;O;7!B;O;4!B;O;O;B;B;O;B;B;O;O;B;B;O;B;B;O;L
	O;8!B;O;3!B;O;O;4!B;11!O;4!B;O;O;3!B;O;8!B;O;L;O;3!B;O;9!B;O;O;17!B;O;O;9!B;O;3!B;O;L
	4!O;11!B;19!O;11!B;4!O;L;16!B;O;B;O;11!B;O;B;O;L;19!B;11!O;L;19!B;O;9!B;O;L;20!B;9!O;L
	24!B;O;L;20!B;3!O;3!B;3!O;L;22!B;O;3!B;O;L;L;21!B;3!O;B;3!O;L;21!B;3!O;B;3!O;L
	20!B;O;B;O;O;B;O;O;B;O;L;20!B;3!O;3!B;3!O;L;21!B;O;5!B;O;E
	OCTAL

RMAX,	DECIMAL
	18!B;O;8!B;L;17!B;3!O;7!B;L;12!B;3!O;4!B;2!O;6!B;L;11!B;O;2!B;3!O;2!B;O;B;2!O;4!B;L
	10!B;O;3!B;O;B;O;2!B;O;B;O;5!B;L;10!B;O;4!B;O;B;O;B;O;B;O;B;2!O;2!B;L
	12!B;O;4!B;O;B;O;3!B;2!O;2!B;L;4!O;5!B;O;B;O;4!B;O;3!B;O;B;3!O;2!B;L
	;O;3!B;2!O;B;O;B;3!O;B;2!O;9!B;2!O;B;L;O;5!B;2!O;5!B;O;13!B;L
	B;O;2!B;2!O;B;O;2!B;O;2!B;O;B;2!O;10!B;L;7!B;O;B;O;B;O;B;O;B;O;B;O;5!B;4!O;L
	B;O;2!B;2!O;B;O;2!B;O;2!B;O;2!B;2!O;B;O;B;2!O;3!B;O;L;O;5!B;2!O;3!B;O;B;O;B;O;3!B;2!O;5!B;O;L
	O;3!B;2!O;B;O;B;2!O;2!B;O;2!B;O;2!B;O;B;2!O;2!B;O;B;L;4!O;5!B;O;B;O;B;O;B;O;B;O;B;O;7!B;L
	10!B;2!O;B;O;2!B;O;2!B;O;B;2!O;2!B;O;B;L;13!B;O;5!B;2!O;5!B;O;L;B;2!O;9!B;2!O;B;3!O;B;O;B;2!O;3!B;O;L
	2!B;3!O;B;O;3!B;O;4!B;O;B;O;5!B;4!O;L;2!B;2!O;3!B;O;B;O;4!B;O;12!B;L
	2!B;2!O;B;O;B;O;B;O;B;O;4!B;O;10!B;L;5!B;O;B;O;2!B;O;B;O;3!B;O;10!B;L
	4!B;2!O;B;O;2!B;3!O;2!B;O;11!B;L;6!B;2!O;4!B;3!O;12!B;L;7!B;3!O;17!B;L;8!B;O;E
	OCTAL
$

